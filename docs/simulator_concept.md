# Симулятор каскадного чтения сигналов (диапазон 1–23)

Цель этого модуля — связать физические сигналы (временные ряды, спектры,
описания событий) с каскадной шкалой уровней 1–23. Мы рассматриваем
каскады как дискретные «ноты» внутри первого диапазона скрипичного ключа.

Симулятор **не претендует** на физическую модель 3I/ATLAS. Это рабочий
инструмент для:
- экспериментов с искусственными сигналами;
- аккуратной проекции реальных наблюдений в каскадную шкалу;
- подготовки визуализаций (например, точки на спирали скрипичного ключа).

## Общая архитектура

Симулятор делится на четыре логических блока:

1. **Загрузка и нормализация сигналов** (`src/core/signal_loader.py`)
2. **Каскадная шкала 1–23** (`src/core/cascade_scale.py`)
3. **Проекция сигналов в каскады** (`src/core/cascade_mapping.py`)
4. **(Опционально) Визуализация** (`src/core/treble_spiral.py`, в будущем)

### 1. Загрузка и нормализация сигналов

Модуль `signal_loader` отвечает за приведение данных к стандартной форме.

Типы входов:
- синтетические сигналы (набор гармоник, синусы с заданными частотами)
  — для тестов и отладки;
- простые CSV-временные ряды вида:
  `time, value` или `time, flux`;
- в будущем — импорт астрономических данных (FITS, каталоги и т.п.).

Задача модуля:
- прочитать источник;
- вернуть:
  - временной ряд (`time, value`) или
  - частотный спектр (`freq, power`),
- нормализовать значения (масштаб, вычитание среднего, при необходимости).

### 2. Каскадная шкала 1–23

Модуль `cascade_scale` задаёт дискретную шкалу для каскадов 1–23.

В первом приближении:
- каждый каскад имеет:
  - `cascade_id` (1…23);
  - `position` в промежутке [0, 1] — условная «координата» по шкале;
  - текстовые метки (`label_ru`, `label_en`) — короткое описание или имя ноты;
- шкала разносится равномерно (равномерная «сетка» по позиции).

Семантические описания (полные метафоры, соответствие нотам и образам)
живут в других документах и **не зашиваются жёстко** в код, чтобы симулятор
оставался нейтральным.

### 3. Проекция сигналов в каскады

Модуль `cascade_mapping` реализует базовый алгоритм:

1. Получить спектр сигнала: пары (`freq`, `power`).
2. Выделить доминирующий диапазон частот (например, максимум по `power`
   или набор пиков).
3. Нормализовать интересующий диапазон в интервал [0, 1].
4. Сопоставить полученную «позицию» каскадам 1–23 по их `position`.
5. Вернуть:
   - основной каскад (`main_cascade`);
   - вектор весов по всем каскадам (`cascade_vector`);
   - при желании — оценку «уверенности».

Функции:
- `compute_cascade_vector(freq, power, scale) -> np.ndarray`
- `map_dominant_cascade(freq, power, scale) -> dict`  
  (например, `{"main_cascade": 19, "confidence": 0.8}`)

### 4. Визуализация (будущее расширение)

Отдельный модуль может строить:

- линейные графики вида «сигнал → каскадная проекция»;
- точку на схеме скрипичного ключа (спираль) для выбранного каскада;
- карты событий: «все наблюдения 3I/ATLAS и их позиции в диапазоне 1–23».

Это планируется как следующий шаг, после того как ядро (загрузка + мэппинг)
будет стабильно работать.

## Поток данных

Типичный сценарий:

1. Загрузить или сгенерировать сигнал:

   ```python
   from src.core.signal_loader import generate_test_signal, compute_spectrum

   t, x = generate_test_signal(...)         # синтетика
   freq, power = compute_spectrum(t, x)     # спектр



2. Получить каскадную шкалу:

from src.core.cascade_scale import get_public_scale

scale = get_public_scale()  # каскады 1–23



3. Спроецировать сигнал в каскады:

from src.core.cascade_mapping import map_dominant_cascade

result = map_dominant_cascade(freq, power, scale)
# result: {"main_cascade": 19, "confidence": 0.7, "vector": np.ndarray}



4. Сохранить результат в журнал наблюдений / использовать для визуализации.


Тестирование

Для симулятора будут добавлены простые тесты:

tests/test_cascade_mapping.py:

проверка, что для синтетического сигнала с одной доминирующей частотой
функция map_dominant_cascade возвращает устойчиво один и тот же
каскад (при фиксированной шкале);

в дальнейшем — тесты консистентности (например, монотонность сопоставления
позиции и номера каскада).



---

## 2. Модуль шкалы каскадов

**Файл:** `src/core/cascade_scale.py`

```python
# src/core/cascade_scale.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class CascadeLevel:
    """
    Описание одного уровня каскада в симуляторе.

    Здесь мы используем нейтральные поля:
    - cascade_id: номер уровня (1..23),
    - position: числовая координата в [0, 1] для проекции,
    - label_ru / label_en: короткие текстовые подписи.

    Полные метафоры, связь с нотами, образами и т.п. задаются
    в документации и могут дополняться отдельно.
    """
    cascade_id: int
    position: float
    label_ru: str
    label_en: str


def get_public_scale() -> List[CascadeLevel]:
    """
    Возвращает публичную шкалу каскадов 1–23.

    В первом приближении уровни равномерно распределены по [0, 1].
    При необходимости эту шкалу можно уточнить (например, сместить
    некоторые уровни в соответствии с музыкальным строем).
    """
    levels: List[CascadeLevel] = []

    # Равномерная сетка по 23 уровням (0.0 .. 1.0)
    n_levels = 23
    for cid in range(1, n_levels + 1):
        # Нормализованная позиция: 0.0 для 1-го, 1.0 для 23-го
        position = (cid - 1) / (n_levels - 1)

        # Минимальные подписи, которые можно уточнить позже
        label_ru = f"Каскад {cid}"
        label_en = f"Cascade {cid}"

        levels.append(
            CascadeLevel(
                cascade_id=cid,
                position=position,
                label_ru=label_ru,
                label_en=label_en,
            )
        )

    return levels

